router id {{ tunnel_local_address }};
log syslog all;

{% set tunnel_group = tunnel_group | default((groups | dict2items | selectattr('key', 'match', '^(gre|wireguard|vxlan)[0-9]+') | selectattr('value', 'contains', inventory_hostname) | map(attribute='key') | first) | default('vxlan1')) %}
{% set is_client = tunnel_type == 'client' %}
{% set group_num = tunnel_group | regex_replace('^(gre|wireguard|vxlan)', '') | int %}
{% set as_prefix = '60' ~ group_num ~ '0' %}  {# Changed 1 to 0 here #}
{% set enable_ecmp = enable_ecmp | default(false) %}
{% set enable_path_isolation = enable_path_isolation | default(false) %}
{% set path_community = '65000:' ~ group_num %}
{% if 'KUBE_WORKERS_1' in vars and inventory_hostname in KUBE_WORKERS_1 %}
    {% set workers_index = 1 %}
{% elif 'KUBE_WORKERS_2' in vars and inventory_hostname in KUBE_WORKERS_2 %}
    {% set workers_index = 2 %}
{% else %}
    {% set workers_index = 1 if tunnel_type == 'src' or tunnel_type == 'client' else 2 %}
{% endif %}

{% if is_client %}
    {% set local_as = '6' ~ group_num ~ '99' ~ '13' %}
    {% set remote_as = '6' ~ group_num ~ '1' ~ '13' %}
{% else %}
    {% set local_as = '6' ~ group_num ~ workers_index ~ '13' %}
    {% set remote_as = '6' ~ workers_index ~ '012' %}
{% endif %}

{# Path isolation: Define community for this tunnel path #}
{% if enable_path_isolation %}
define PATH_COMMUNITY = (65000, {{ group_num }});
{% endif %}

{# ============================================== #}
{# TUNNEL FILTERS - Used for tunnel-to-tunnel BGP #}
{# ============================================== #}

{# Export filter for tunnel peers: tag with path community #}
function set_tunnel_nexthops()
{
{% if enable_path_isolation %}
  {# Tag routes with our path community #}
  bgp_community.add(PATH_COMMUNITY);
{% endif %}
  {# Use consistent metrics for tunnel peering #}
  bgp_med = 100;
  bgp_local_pref = 300;
  accept;
}

filter tunnel_export {
  set_tunnel_nexthops();
}

{% if enable_path_isolation %}
{# Import filter for tunnel peers: prefer routes from same path #}
filter tunnel_import {
  if (PATH_COMMUNITY ~ bgp_community) then {
    {# Route came from our path - high preference #}
    bgp_local_pref = 500;
  } else {
    {# Route came from different path - low preference (backup only) #}
    bgp_local_pref = 50;
  }
  accept;
}

{# Strict tunnel import: reject routes from other paths entirely #}
filter tunnel_import_strict {
  if (PATH_COMMUNITY ~ bgp_community) then {
    bgp_local_pref = 500;
    accept;
  }
  reject;
}
{% endif %}

{# ============================================== #}
{# CALICO/ECMP FILTERS - Used for worker BGP     #}
{# ============================================== #}

{# Export filter for Calico workers: ECMP-friendly, equal metrics #}
function set_ecmp_nexthops()
{
  {# Use equal attributes for ECMP across all tunnel groups #}
  bgp_med = 100;
  bgp_local_pref = 300;
  {# Do NOT add path community - Calico doesn't need it #}
  accept;
}

filter ecmp_export {
  set_ecmp_nexthops();
}

{# Import filter for Calico workers: accept all with equal preference #}
filter ecmp_import {
  bgp_local_pref = 300;
  accept;
}

{# ============================================== #}
{# LEGACY FILTERS - For backward compatibility   #}
{# ============================================== #}

function set_nexthops()
{
{% if enable_ecmp %}
  {# ECMP mode: Use equal attributes for all tunnel groups #}
  bgp_med = 100;
  bgp_local_pref = 300;
  {# No AS path prepending for ECMP #}
{% else %}
  {# Priority mode: Different attributes based on tunnel group #}
  bgp_med = {{ group_num * 100 }};
  bgp_local_pref = {{ (3 - group_num + 1) * 100 }};

  {% set max_priority = 10 %}
  {% set prepend_count = group_num - 1 %}
  {% for _ in range(prepend_count) %}
      bgp_path.prepend({{ local_as }});
  {% endfor %}
{% endif %}

{% if enable_path_isolation %}
  {# Tag routes with our path community when exporting #}
  bgp_community.add(PATH_COMMUNITY);
{% endif %}

  accept;
}

filter nexthops {
  set_nexthops();
}

{% if enable_path_isolation %}
{# Legacy path isolation import filter #}
filter path_isolation_import {
  if (PATH_COMMUNITY ~ bgp_community) then {
    bgp_local_pref = 500;
  } else {
    bgp_local_pref = 50;
  }
  accept;
}

filter path_isolation_strict {
  if (PATH_COMMUNITY ~ bgp_community) then {
    bgp_local_pref = 500;
    accept;
  }
  reject;
}
{% endif %}

{% if local_networks is defined and local_networks|length > 0 %}
protocol static {
    ipv4;
{% for network in local_networks %}
{% set interface = physical_interfaces[loop.index0] %}
    route {{ network }} via "{{ interface.name }}";
{% endfor %}
}
{% endif %}

{# ============================================== #}
{# TUNNEL BGP SESSIONS - Path isolation enabled  #}
{# ============================================== #}

{% if is_client %}
protocol bgp bgp_to_gateway {
    local {{ tunnel_local_address }} as {{ local_as }};
    neighbor {{ tunnel_dest_address }} as {{ gateway_as }};
    ipv4 {
        export filter tunnel_export;
{% if enable_path_isolation %}
        import filter tunnel_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}

{% if tunnel_dest_address_2|default('') != '' %}
protocol bgp bgp_to_gateway_2 {
    local {{ tunnel_local_address }} as {{ local_as }};
    neighbor {{ tunnel_dest_address_2 }} as {{ gateway_as }};
    ipv4 {
        export filter tunnel_export;
{% if enable_path_isolation %}
        import filter tunnel_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endif %}
{% else %}
protocol bgp bgp_to_node{{ dest_index }} {
    local {{ tunnel_local_address }} as {{ as_prefix }}{{ index }};
    neighbor {{ tunnel_dest_address }} as {{ as_prefix }}{{ dest_index }};
    ipv4 {
        export filter tunnel_export;
{% if enable_path_isolation %}
        import filter tunnel_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endif %}

{% if has_vxlan_dual|default(false) %}
protocol bgp bgp_to_node{{ dest_index }}_2 {
    local {{ tunnel_local_address_2 }} as {{ as_prefix }}{{ index }};
    neighbor {{ tunnel_dest_address_2 }} as {{ as_prefix }}{{ dest_index }};
    ipv4 {
        export filter tunnel_export;
{% if enable_path_isolation %}
        import filter tunnel_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endif %}

{#
  BGP from Clients:
  Clients use AS number 6{group_num}9913 (e.g., 619913 for group 1).
  Note: This assumes all clients belong to tunnel group 1.
  If you have clients in multiple tunnel groups, you may need to customize this.
  These sessions are passive (clients connect to BIRD).
#}
{% set enable_client_bgp = enable_bird_from_client_bgp | default(true) %}
{% if has_clients|default(false) and not is_client and enable_client_bgp %}
{% set client_as = '6' ~ group_num ~ '9913' %}
{% for client_ip in client_ips %}
protocol bgp bgp_from_client_{{ loop.index }} {
    local {{ client_interface_1 }} as {{ local_as }};
    neighbor {{ client_ip }} as {{ client_as }};
    ipv4 {
        export filter tunnel_export;
{% if enable_path_isolation %}
        import filter tunnel_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    passive;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endfor %}

{% if client_interface_2|default('') != '' %}
{% for client_ip in client_ips %}
protocol bgp bgp_from_client_{{ loop.index }}_2 {
    local {{ client_interface_2 }} as {{ local_as }};
    neighbor {{ client_ip }} as {{ client_as }};
    ipv4 {
        export filter tunnel_export;
{% if enable_path_isolation %}
        import filter tunnel_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    passive;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endfor %}
{% endif %}
{% endif %}

{# ============================================== #}
{# CALICO/WORKER BGP SESSIONS - ECMP enabled     #}
{# ============================================== #}

{#
  BGP to/from Kubernetes Workers (Calico):
  - Uses ECMP filters (equal metrics) so Calico can load-balance
  - Workers connect TO BIRD in passive mode (Calico BGPPeer)
  - Set enable_bird_to_worker_bgp=true for active mode
#}
{% set enable_worker_bgp = enable_bird_to_worker_bgp | default(false) %}
{% if enable_worker_bgp %}
{# Active BGP sessions: BIRD connects to workers #}
{% set worker_list = vars['KUBE_WORKERS_' ~ workers_index] | default([]) %}

{% for worker in worker_list %}
    {% if 'KUBE_WORKERS_1' in vars and worker in KUBE_WORKERS_1 %}
        {% set remote_index = 1 %}
    {% elif 'KUBE_WORKERS_2' in vars and worker in KUBE_WORKERS_2 %}
        {% set remote_index = 2 %}
    {% else %}
        {% set remote_index = 1 if tunnel_type == 'src' else 2 %}
    {% endif %}

    {% set remote_as = '6' ~ remote_index ~ '012' %}
protocol bgp bgp_to_worker_{{ worker.split('.')[-1] }} {
    local {{ local_ip }} as {{ local_as }};
    neighbor {{ worker }} as {{ remote_as }};
    ipv4 {
        export filter ecmp_export;
        import filter ecmp_import;
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endfor %}
{% else %}
{# Passive BGP sessions: Workers connect to BIRD (Calico mode) #}
{# Create a passive session for each worker that may connect #}
{% set worker_list = vars['KUBE_WORKERS_' ~ workers_index] | default([]) %}
{% if worker_list | length > 0 and not is_client %}
{% set worker_as = '6' ~ workers_index ~ '012' %}
{% for worker_ip in worker_list %}
protocol bgp bgp_from_worker_{{ worker_ip.split('.')[-1] }} {
    local {{ local_ip }} as {{ local_as }};
    neighbor {{ worker_ip }} as {{ worker_as }};
    ipv4 {
        export filter ecmp_export;
        import filter ecmp_import;
        next hop self;
    };
    passive;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endfor %}
{% endif %}
{% endif %}

protocol kernel {
    ipv4 {
        import none;
        export all;
    };
    scan time 60;
}

protocol device {
    scan time 60;
}

