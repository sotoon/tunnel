router id {{ tunnel_local_address }};
log syslog all;

{% set tunnel_group = tunnel_group | default((groups | dict2items | selectattr('key', 'match', '^(gre|wireguard|vxlan)[0-9]+') | selectattr('value', 'contains', inventory_hostname) | map(attribute='key') | first) | default('vxlan1')) %}
{% set is_client = tunnel_type == 'client' %}
{% set group_num = tunnel_group | regex_replace('^(gre|wireguard|vxlan)', '') | int %}
{% set as_prefix = '60' ~ group_num ~ '0' %}  {# Changed 1 to 0 here #}
{% set enable_ecmp = enable_ecmp | default(false) %}
{% set enable_path_isolation = enable_path_isolation | default(false) %}
{% set path_community = '65000:' ~ group_num %}
{% if 'KUBE_WORKERS_1' in vars and inventory_hostname in KUBE_WORKERS_1 %}
    {% set workers_index = 1 %}
{% elif 'KUBE_WORKERS_2' in vars and inventory_hostname in KUBE_WORKERS_2 %}
    {% set workers_index = 2 %}
{% else %}
    {% set workers_index = 1 if tunnel_type == 'src' or tunnel_type == 'client' else 2 %}
{% endif %}

{% if is_client %}
    {% set local_as = '6' ~ group_num ~ '99' ~ '13' %}
    {% set remote_as = '6' ~ group_num ~ '1' ~ '13' %}
{% else %}
    {% set local_as = '6' ~ group_num ~ workers_index ~ '13' %}
    {% set remote_as = '6' ~ workers_index ~ '012' %}
{% endif %}

{# Path isolation: Define community for this tunnel path #}
{% if enable_path_isolation %}
define PATH_COMMUNITY = (65000, {{ group_num }});
{% endif %}

function set_nexthops()
{
{% if enable_ecmp %}
  {# ECMP mode: Use equal attributes for all tunnel groups #}
  bgp_med = 100;
  bgp_local_pref = 300;
  {# No AS path prepending for ECMP #}
{% else %}
  {# Priority mode: Different attributes based on tunnel group #}
  bgp_med = {{ group_num * 100 }};
  bgp_local_pref = {{ (3 - group_num + 1) * 100 }};

  {% set max_priority = 10 %}
  {% set prepend_count = group_num - 1 %}
  {% for _ in range(prepend_count) %}
      bgp_path.prepend({{ local_as }});
  {% endfor %}
{% endif %}

{% if enable_path_isolation %}
  {# Tag routes with our path community when exporting #}
  bgp_community.add(PATH_COMMUNITY);
{% endif %}

  accept;
}
filter nexthops {
  set_nexthops();
}

{% if enable_path_isolation %}
{# Import filter for path isolation: prefer routes from same tunnel path #}
filter path_isolation_import {
  if (PATH_COMMUNITY ~ bgp_community) then {
    {# Route came from our path - high preference #}
    bgp_local_pref = 500;
  } else {
    {# Route came from different path - low preference (backup only) #}
    bgp_local_pref = 50;
  }
  accept;
}

{# Strict path isolation: reject routes from other paths entirely #}
filter path_isolation_strict {
  if (PATH_COMMUNITY ~ bgp_community) then {
    bgp_local_pref = 500;
    accept;
  }
  {# Reject routes without our path community #}
  reject;
}
{% endif %}

{% if local_networks is defined and local_networks|length > 0 %}
protocol static {
    ipv4;
{% for network in local_networks %}
{% set interface = physical_interfaces[loop.index0] %}
    route {{ network }} via "{{ interface.name }}";
{% endfor %}
}
{% endif %}

{% if is_client %}
protocol bgp bgp_to_gateway {
    local {{ tunnel_local_address }} as {{ local_as }};
    neighbor {{ tunnel_dest_address }} as {{ gateway_as }};
    ipv4 {
        export filter nexthops;
{% if enable_path_isolation %}
        import filter path_isolation_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}

{% if tunnel_dest_address_2|default('') != '' %}
protocol bgp bgp_to_gateway_2 {
    local {{ tunnel_local_address }} as {{ local_as }};
    neighbor {{ tunnel_dest_address_2 }} as {{ gateway_as }};
    ipv4 {
        export filter nexthops;
{% if enable_path_isolation %}
        import filter path_isolation_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endif %}
{% else %}
protocol bgp bgp_to_node{{ dest_index }} {
    local {{ tunnel_local_address }} as {{ as_prefix }}{{ index }};
    neighbor {{ tunnel_dest_address }} as {{ as_prefix }}{{ dest_index }};
    ipv4 {
        export filter nexthops;
{% if enable_path_isolation %}
        import filter path_isolation_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endif %}

{% if has_vxlan_dual|default(false) %}
protocol bgp bgp_to_node{{ dest_index }}_2 {
    local {{ tunnel_local_address_2 }} as {{ as_prefix }}{{ index }};
    neighbor {{ tunnel_dest_address_2 }} as {{ as_prefix }}{{ dest_index }};
    ipv4 {
        export filter nexthops;
{% if enable_path_isolation %}
        import filter path_isolation_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endif %}

{#
  BGP from Clients:
  Clients use AS number 6{group_num}9913 (e.g., 619913 for group 1).
  Note: This assumes all clients belong to tunnel group 1.
  If you have clients in multiple tunnel groups, you may need to customize this.
  These sessions are passive (clients connect to BIRD).
#}
{% set enable_client_bgp = enable_bird_from_client_bgp | default(true) %}
{% if has_clients|default(false) and not is_client and enable_client_bgp %}
{% set client_as = '6' ~ group_num ~ '9913' %}
{% for client_ip in client_ips %}
protocol bgp bgp_from_client_{{ loop.index }} {
    local {{ client_interface_1 }} as {{ local_as }};
    neighbor {{ client_ip }} as {{ client_as }};
    ipv4 {
        export filter nexthops;
{% if enable_path_isolation %}
        import filter path_isolation_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    passive;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endfor %}

{% if client_interface_2|default('') != '' %}
{% for client_ip in client_ips %}
protocol bgp bgp_from_client_{{ loop.index }}_2 {
    local {{ client_interface_2 }} as {{ local_as }};
    neighbor {{ client_ip }} as {{ client_as }};
    ipv4 {
        export filter nexthops;
{% if enable_path_isolation %}
        import filter path_isolation_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    passive;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endfor %}
{% endif %}
{% endif %}

{#
  BGP to/from Kubernetes Workers:
  When using Calico with BGPPeer resources, workers connect TO BIRD (passive mode).
  Only create active BGP sessions from BIRD to workers if explicitly enabled.
#}
{% set enable_worker_bgp = enable_bird_to_worker_bgp | default(false) %}
{% if enable_worker_bgp %}
{# Active BGP sessions: BIRD connects to workers #}
{% set worker_list = vars['KUBE_WORKERS_' ~ workers_index] | default([]) %}

{% for worker in worker_list %}
    {% if 'KUBE_WORKERS_1' in vars and worker in KUBE_WORKERS_1 %}
        {% set remote_index = 1 %}
    {% elif 'KUBE_WORKERS_2' in vars and worker in KUBE_WORKERS_2 %}
        {% set remote_index = 2 %}
    {% else %}
        {% set remote_index = 1 if tunnel_type == 'src' else 2 %}
    {% endif %}

    {% set remote_as = '6' ~ remote_index ~ '012' %}
protocol bgp bgp_to_worker_{{ worker.split('.')[-1] }} {
    local {{ local_ip }} as {{ local_as }};
    neighbor {{ worker }} as {{ remote_as }};
    ipv4 {
        export filter nexthops;
{% if enable_path_isolation %}
        import filter path_isolation_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    direct;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endfor %}
{% else %}
{# Passive BGP sessions: Workers connect to BIRD (Calico mode) #}
{# Create a passive session for each worker that may connect #}
{% set worker_list = vars['KUBE_WORKERS_' ~ workers_index] | default([]) %}
{% if worker_list | length > 0 and not is_client %}
{% set worker_as = '6' ~ workers_index ~ '012' %}
{% for worker_ip in worker_list %}
protocol bgp bgp_from_worker_{{ worker_ip.split('.')[-1] }} {
    local {{ local_ip }} as {{ local_as }};
    neighbor {{ worker_ip }} as {{ worker_as }};
    ipv4 {
        export filter nexthops;
{% if enable_path_isolation %}
        import filter path_isolation_import;
{% else %}
        import all;
{% endif %}
        next hop self;
    };
    passive;
    hold time 240;
    keepalive time 80;
    connect delay time 2;
    connect retry time 5;
    error wait time 5,30;
}
{% endfor %}
{% endif %}
{% endif %}

protocol kernel {
    ipv4 {
        import none;
        export all;
    };
    scan time 60;
}

protocol device {
    scan time 60;
}

