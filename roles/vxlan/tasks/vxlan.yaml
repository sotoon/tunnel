- name: Ensure iproute2 is installed
  become: true
  apt:
    name: iproute2
    state: present

- name: Enable and persist IP forwarding (net.ipv4.ip_forward=1)
  become: true
  sysctl:
    name: net.ipv4.ip_forward
    value: "1"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Enable multipath hash policy (net.ipv4.fib_multipath_hash_policy=1)
  become: true
  sysctl:
    name: net.ipv4.fib_multipath_hash_policy
    value: "1"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Enable multipath neighbor usage (net.ipv4.fib_multipath_use_neigh=1)
  become: true
  sysctl:
    name: net.ipv4.fib_multipath_use_neigh
    value: "1"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Get physical interface name for sysctls
  set_fact:
    vxlan_physical_interface: "{{ physical_interfaces[0].name }}"
    vxlan_interface: "vxlan-{{ physical_interfaces[0].name }}"
  when: physical_interfaces is defined and physical_interfaces | length > 0

- name: Disable rp_filter for all interfaces
  become: true
  sysctl:
    name: net.ipv4.conf.all.rp_filter
    value: "0"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Disable rp_filter for default interface
  become: true
  sysctl:
    name: net.ipv4.conf.default.rp_filter
    value: "0"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Disable rp_filter for physical interface
  become: true
  sysctl:
    name: "net.ipv4.conf.{{ vxlan_physical_interface }}.rp_filter"
    value: "0"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf
  when: vxlan_physical_interface is defined

- name: Disable rp_filter for VXLAN interface
  become: true
  sysctl:
    name: "net.ipv4.conf.{{ vxlan_interface }}.rp_filter"
    value: "0"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf
  when: vxlan_interface is defined

- name: Set netfilter conntrack max
  become: true
  sysctl:
    name: net.netfilter.nf_conntrack_max
    value: "1048576"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set netfilter conntrack TCP timeout established
  become: true
  sysctl:
    name: net.netfilter.nf_conntrack_tcp_timeout_established
    value: "7200"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set netfilter conntrack TCP timeout time wait
  become: true
  sysctl:
    name: net.netfilter.nf_conntrack_tcp_timeout_time_wait
    value: "30"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set netfilter conntrack TCP timeout close wait
  become: true
  sysctl:
    name: net.netfilter.nf_conntrack_tcp_timeout_close_wait
    value: "60"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set netfilter conntrack TCP timeout fin wait
  become: true
  sysctl:
    name: net.netfilter.nf_conntrack_tcp_timeout_fin_wait
    value: "30"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set netfilter conntrack TCP timeout syn recv
  become: true
  sysctl:
    name: net.netfilter.nf_conntrack_tcp_timeout_syn_recv
    value: "30"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set netfilter conntrack generic timeout
  become: true
  sysctl:
    name: net.netfilter.nf_conntrack_generic_timeout
    value: "120"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set IP local port range
  become: true
  sysctl:
    name: net.ipv4.ip_local_port_range
    value: "1024 65535"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Enable TCP time wait reuse
  become: true
  sysctl:
    name: net.ipv4.tcp_tw_reuse
    value: "1"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set core receive memory max
  become: true
  sysctl:
    name: net.core.rmem_max
    value: "16777216"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set core write memory max
  become: true
  sysctl:
    name: net.core.wmem_max
    value: "16777216"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set core receive memory default
  become: true
  sysctl:
    name: net.core.rmem_default
    value: "262144"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set core write memory default
  become: true
  sysctl:
    name: net.core.wmem_default
    value: "262144"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set TCP receive memory
  become: true
  sysctl:
    name: net.ipv4.tcp_rmem
    value: "4096 131072 16777216"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set TCP write memory
  become: true
  sysctl:
    name: net.ipv4.tcp_wmem
    value: "4096 131072 16777216"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set TCP memory
  become: true
  sysctl:
    name: net.ipv4.tcp_mem
    value: "1048576 1572864 2097152"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set core netdev max backlog
  become: true
  sysctl:
    name: net.core.netdev_max_backlog
    value: "250000"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set core somaxconn
  become: true
  sysctl:
    name: net.core.somaxconn
    value: "65535"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Set TCP max syn backlog
  become: true
  sysctl:
    name: net.ipv4.tcp_max_syn_backlog
    value: "65535"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Calculate peer network from peer physical interface
  set_fact:
    peer_interface_ip: "{{ hostvars[peer_host]['physical_interfaces'][0].ip }}"
  when: tunnel_type == "src" and physical_interfaces is defined

- name: Extract peer network range
  command: python3 -c "import ipaddress; print(ipaddress.ip_network('{{ peer_interface_ip }}', strict=False).with_prefixlen)"
  register: peer_network_result
  when: tunnel_type == "src" and physical_interfaces is defined

- name: Set peer network range fact
  set_fact:
    peer_network_range: "{{ peer_network_result.stdout }}"
  when: tunnel_type == "src" and physical_interfaces is defined

- name: Setup VXLAN config for eth0 (machine to engine)
  become: true
  become_user: root
  template:
    src: 90-vxlan.yaml.j2
    dest: /etc/netplan/90-vxlan-eth0.yaml
    mode: "0400"
  vars:
    remote_ip: "{{ hostvars[peer_host]['public_ip'] }}"
    index: "{{ (groups['all'] | list).index(inventory_hostname) + 1 }}"
    tunnel_address: "{{ vxlan_ip_range }}.{{ index }}/{{ vxlan_cidr }}"
    vxlan_id: 101
    vxlan_port: 4789
    local_ip: "{{ physical_interfaces[0].ip.split('/')[0] }}"
    interface_name: "eth0"
    vxlan_interface_name: "vxlan-eth0"
    interface_index: 0
    remote_network_range: "{{ peer_network_range }}"
    remote_tunnel_ip: "{{ vxlan_ip_range }}.{{ (groups['all'] | list).index(peer_host) + 1 }}"
  when: tunnel_type == "src" and physical_interfaces is defined

- name: Calculate peer network from peer physical interface (engine side)
  set_fact:
    peer_interface_ip: "{{ hostvars[peer_host]['physical_interfaces'][0].ip }}"
  when: tunnel_type == "dest" and physical_interfaces is defined

- name: Extract peer network range (engine side)
  command: python3 -c "import ipaddress; print(ipaddress.ip_network('{{ peer_interface_ip }}', strict=False).with_prefixlen)"
  register: peer_network_result
  when: tunnel_type == "dest" and physical_interfaces is defined

- name: Set peer network range fact (engine side)
  set_fact:
    peer_network_range: "{{ peer_network_result.stdout }}"
  when: tunnel_type == "dest" and physical_interfaces is defined

- name: Setup VXLAN config for engine (engine to machine eth0)
  become: true
  become_user: root
  template:
    src: 90-vxlan.yaml.j2
    dest: /etc/netplan/90-vxlan-eth0.yaml
    mode: "0400"
  vars:
    remote_ip: "{{ vxlan_remote_ips.eth0 | default(hostvars[peer_host]['public_ip']) }}"
    index: "{{ (groups['all'] | list).index(inventory_hostname) + 1 }}"
    tunnel_address: "{{ vxlan_ip_range }}.{{ index }}/{{ vxlan_cidr }}"
    vxlan_id: 101
    vxlan_port: 4789
    local_ip: "{{ physical_interfaces[0].ip.split('/')[0] }}"
    interface_name: "ens3"
    vxlan_interface_name: "vxlan-eth0"
    interface_index: 0
    remote_network_range: "{{ peer_network_range }}"
    remote_tunnel_ip: "{{ vxlan_ip_range }}.{{ (groups['all'] | list).index(peer_host) + 1 }}"
  when: tunnel_type == "dest" and physical_interfaces is defined

- name: Start VXLAN
  become: true
  command: netplan apply

- name: Get default route interface
  become: true
  command: ip route show default
  register: default_route
  when: tunnel_type == "dest"

- name: Extract main interface from default route
  set_fact:
    main_interface: "{{ default_route.stdout.split(' ')[4] }}"
  when: tunnel_type == "dest"

- name: Ensure iptables-persistent is installed
  become: true
  apt:
    name: iptables-persistent
    state: present
  when: ansible_os_family == "Debian"

- name: Get default route interface for machines
  become: true
  command: ip route show default
  register: default_route_machine
  when: tunnel_type == "src"

- name: Extract main interface from default route for machines
  set_fact:
    main_interface_machine: "{{ default_route_machine.stdout.split(' ')[4] }}"
  when: tunnel_type == "src"

- name: Ensure MASQUERADE rule exists on main interface for machines
  become: true
  ansible.builtin.iptables:
    table: nat
    chain: POSTROUTING
    out_interface: "{{ main_interface_machine }}"
    jump: MASQUERADE
    state: present
  when: tunnel_type == "src"

- name: Ensure MASQUERADE rule exists on main interface for engines
  become: true
  ansible.builtin.iptables:
    table: nat
    chain: POSTROUTING
    out_interface: "{{ main_interface }}"
    jump: MASQUERADE
    state: present
  when: tunnel_type == "dest"

- name: Save iptables rules
  become: true
  command: netfilter-persistent save
  when: ansible_os_family == "Debian"
  changed_when: false
