- name: Ensure iproute2 is installed
  become: true
  apt:
    name: iproute2
    state: present

- name: Enable and persist IP forwarding (net.ipv4.ip_forward=1)
  become: true
  sysctl:
    name: net.ipv4.ip_forward
    value: "1"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Enable multipath hash policy (net.ipv4.fib_multipath_hash_policy=1)
  become: true
  sysctl:
    name: net.ipv4.fib_multipath_hash_policy
    value: "1"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Enable multipath neighbor usage (net.ipv4.fib_multipath_use_neigh=1)
  become: true
  sysctl:
    name: net.ipv4.fib_multipath_use_neigh
    value: "1"
    state: present
    reload: true
    sysctl_file: /etc/sysctl.conf

- name: Calculate peer network from peer physical interface
  set_fact:
    peer_interface_ip: "{{ hostvars[peer_host]['physical_interfaces'][0].ip }}"
  when: tunnel_type == "src" and physical_interfaces is defined

- name: Extract peer network range
  command: python3 -c "import ipaddress; print(ipaddress.ip_network('{{ peer_interface_ip }}', strict=False).with_prefixlen)"
  register: peer_network_result
  when: tunnel_type == "src" and physical_interfaces is defined

- name: Set peer network range fact
  set_fact:
    peer_network_range: "{{ peer_network_result.stdout }}"
  when: tunnel_type == "src" and physical_interfaces is defined

- name: Setup VXLAN config for eth0 (machine to engine)
  become: true
  become_user: root
  template:
    src: 90-vxlan.yaml.j2
    dest: /etc/netplan/90-vxlan-eth0.yaml
    mode: "0400"
  vars:
    remote_ip: "{{ hostvars[peer_host]['public_ip'] }}"
    index: "{{ (groups['all'] | list).index(inventory_hostname) + 1 }}"
    tunnel_address: "{{ vxlan_ip_range }}.{{ index }}/{{ vxlan_cidr }}"
    vxlan_id: 101
    vxlan_port: 4789
    local_ip: "{{ physical_interfaces[0].ip.split('/')[0] }}"
    interface_name: "eth0"
    vxlan_interface_name: "vxlan-eth0"
    interface_index: 0
    remote_network_range: "{{ peer_network_range }}"
    remote_tunnel_ip: "{{ vxlan_ip_range }}.{{ (groups['all'] | list).index(peer_host) + 1 }}"
  when: tunnel_type == "src" and physical_interfaces is defined

- name: Calculate peer network from peer physical interface (engine side)
  set_fact:
    peer_interface_ip: "{{ hostvars[peer_host]['physical_interfaces'][0].ip }}"
  when: tunnel_type == "dest" and physical_interfaces is defined

- name: Extract peer network range (engine side)
  command: python3 -c "import ipaddress; print(ipaddress.ip_network('{{ peer_interface_ip }}', strict=False).with_prefixlen)"
  register: peer_network_result
  when: tunnel_type == "dest" and physical_interfaces is defined

- name: Set peer network range fact (engine side)
  set_fact:
    peer_network_range: "{{ peer_network_result.stdout }}"
  when: tunnel_type == "dest" and physical_interfaces is defined

- name: Setup VXLAN config for engine (engine to machine eth0)
  become: true
  become_user: root
  template:
    src: 90-vxlan.yaml.j2
    dest: /etc/netplan/90-vxlan-eth0.yaml
    mode: "0400"
  vars:
    remote_ip: "{{ vxlan_remote_ips.eth0 | default(hostvars[peer_host]['public_ip']) }}"
    index: "{{ (groups['all'] | list).index(inventory_hostname) + 1 }}"
    tunnel_address: "{{ vxlan_ip_range }}.{{ index }}/{{ vxlan_cidr }}"
    vxlan_id: 101
    vxlan_port: 4789
    local_ip: "{{ physical_interfaces[0].ip.split('/')[0] }}"
    interface_name: "ens3"
    vxlan_interface_name: "vxlan-eth0"
    interface_index: 0
    remote_network_range: "{{ peer_network_range }}"
    remote_tunnel_ip: "{{ vxlan_ip_range }}.{{ (groups['all'] | list).index(peer_host) + 1 }}"
  when: tunnel_type == "dest" and physical_interfaces is defined

- name: Start VXLAN
  become: true
  command: netplan apply

- name: Get default route interface
  become: true
  command: ip route show default
  register: default_route
  when: tunnel_type == "dest"

- name: Extract main interface from default route
  set_fact:
    main_interface: "{{ default_route.stdout.split(' ')[4] }}"
  when: tunnel_type == "dest"

- name: Get all interface IPs
  become: true
  command: ip -4 -o addr show
  register: interface_ips
  when: tunnel_type == "dest"

- name: Set fact if any IP is in 10.0.0.0/24
  set_fact:
    is_10_0_range: "{{ interface_ips.stdout_lines | select('search', '\\s10\\.0\\.0\\.') | list | length > 0 }}"
  when: tunnel_type == "dest"

- name: Get all interface IPs for machines
  become: true
  command: ip -4 -o addr show
  register: interface_ips_machine
  when: tunnel_type == "src"

- name: Set fact if any IP is in 10.0.0.0/16 for machines
  set_fact:
    is_10_0_range: "{{ interface_ips_machine.stdout_lines | select('search', '\\s10\\.0\\.') | list | length > 0 }}"
  when: tunnel_type == "src"

- name: Ensure iptables-persistent is installed
  become: true
  apt:
    name: iptables-persistent
    state: present
  when: ansible_os_family == "Debian" and is_10_0_range | default(false)

- name: Get default route interface for machines
  become: true
  command: ip route show default
  register: default_route_machine
  when: tunnel_type == "src" and is_10_0_range | default(false)

- name: Extract main interface from default route for machines
  set_fact:
    main_interface_machine: "{{ default_route_machine.stdout.split(' ')[4] }}"
  when: tunnel_type == "src" and is_10_0_range | default(false)

- name: Ensure MASQUERADE rule exists on main interface for machines
  become: true
  ansible.builtin.iptables:
    table: nat
    chain: POSTROUTING
    out_interface: "{{ main_interface_machine }}"
    jump: MASQUERADE
    state: present
  when: tunnel_type == "src" and is_10_0_range | default(false)

- name: Ensure MASQUERADE rule exists on main interface for engines
  become: true
  ansible.builtin.iptables:
    table: nat
    chain: POSTROUTING
    out_interface: "{{ main_interface }}"
    jump: MASQUERADE
    state: present
  when: tunnel_type == "dest" and is_10_0_range | default(false)

- name: Save iptables rules
  become: true
  command: netfilter-persistent save
  when: ansible_os_family == "Debian" and is_10_0_range | default(false)
  changed_when: false
