#!/usr/bin/env bash
# dynamic-route-parallel.sh
# Monitors probes and updates route {% if inventory_hostname.startswith('machine') %}{{ machine_dynamic_route_target }}{% else %}{{ engine_dynamic_route_target }}{% endif %} via healthy endpoints
# Parallel curl requests for faster results

CURL_TIMEOUT="{% if inventory_hostname.startswith('machine') %}{{ machine_dynamic_route_curl_timeout | default(2) }}{% else %}{{ engine_dynamic_route_curl_timeout | default(2) }}{% endif %}"
ROUTE_TARGET="{% if inventory_hostname.startswith('machine') %}{{ machine_dynamic_route_target }}{% else %}{{ engine_dynamic_route_target }}{% endif %}"
DEV="{% if inventory_hostname.startswith('machine') %}{{ machine_dynamic_route_interface | default('eth0') }}{% else %}{{ engine_dynamic_route_interface | default('ens3') }}{% endif %}"

# Define probes: "label|probe_url|next_hop_ip"
PROBES=(
{% if inventory_hostname.startswith('machine') %}
{% for probe in machine_dynamic_route_probes %}
  "{{ probe.label }}|{{ probe.url }}|{{ probe.next_hop }}"
{% endfor %}
{% else %}
{% for probe in engine_dynamic_route_probes %}
  "{{ probe.label }}|{{ probe.url }}|{{ probe.next_hop }}"
{% endfor %}
{% endif %}
)

{% raw %}

timestamp() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }

# Temp directory for storing probe results
TMPDIR=$(mktemp -d)
trap 'rm -rf "$TMPDIR"' EXIT

# Launch all curls in parallel
for entry in "${PROBES[@]}"; do
  label="${entry%%|*}"
  rest="${entry#*|}"
  url="${rest%%|*}"
  nexthop="${rest##*|}"
  outfile="$TMPDIR/$label.result"

  (
    http_code=$(curl -sS --max-time "$CURL_TIMEOUT" -w "%{http_code}" -o "$outfile.body" "$url" 2>/dev/null || echo "000")
    echo "$http_code" > "$outfile.code"
    echo "$nexthop" >> "$outfile"
  ) &
done

# Wait for all background curls to finish
wait

# Collect healthy nexthops
HEALTHY_NEXTHOPS=()

for entry in "${PROBES[@]}"; do
  label="${entry%%|*}"
  outfile="$TMPDIR/$label.result"
  nexthop=$(tail -n 1 "$outfile")
  http_code=$(cat "$outfile.code")
  body_file="$TMPDIR/$label.result.body"

  if [[ "$http_code" != "200" ]]; then
    echo "$(timestamp) $label UNHEALTHY http=$http_code"
    continue
  fi

  if grep -q 'probe_success 1' "$body_file"; then
    echo "$(timestamp) $label HEALTHY"
    HEALTHY_NEXTHOPS+=("$nexthop")
  else
    echo "$(timestamp) $label UNHEALTHY"
  fi
done

# Get existing nexthops from route if any
EXISTING_NEXTHOPS=($(ip route show "$ROUTE_TARGET" 2>/dev/null | grep -oP 'via \K[0-9.]+' | sort))

# Handle no healthy endpoints
if [[ ${#HEALTHY_NEXTHOPS[@]} -eq 0 ]]; then
  if [[ ${#EXISTING_NEXTHOPS[@]} -gt 0 ]]; then
    echo "$(timestamp) No healthy endpoints. Removing existing route."
    ip route del "$ROUTE_TARGET"
  else
    echo "$(timestamp) No healthy endpoints. No route exists. Nothing to do."
  fi
  exit 0
fi

# Build desired route string
if [[ ${#HEALTHY_NEXTHOPS[@]} -eq 1 ]]; then
  DESIRED_ROUTE="via ${HEALTHY_NEXTHOPS[0]} dev $DEV mtu 1450"
else
  DESIRED_ROUTE=""
  for nh in "${HEALTHY_NEXTHOPS[@]}"; do
    DESIRED_ROUTE+=" nexthop via $nh dev $DEV weight 1"
  done
fi

# Compare existing and desired nexthops
DESIRED_NEXTHOPS=($(printf "%s\n" "${HEALTHY_NEXTHOPS[@]}" | sort))
if [[ "${EXISTING_NEXTHOPS[*]}" == "${DESIRED_NEXTHOPS[*]}" ]]; then
  echo "$(timestamp) Route already exists and matches desired nexthops. Doing nothing."
else
  echo "$(timestamp) Route differs. Replacing with desired route."
  if [[ ${#HEALTHY_NEXTHOPS[@]} -eq 1 ]]; then
    ip route replace "$ROUTE_TARGET" via "${HEALTHY_NEXTHOPS[0]}" dev "$DEV" mtu 1450
  else
    MP_CMD="ip route replace $ROUTE_TARGET mtu 1450"
    for nh in "${HEALTHY_NEXTHOPS[@]}"; do
      MP_CMD+=" nexthop via $nh dev $DEV weight 1"
    done
    eval "$MP_CMD"
  fi
fi
{% endraw %}
